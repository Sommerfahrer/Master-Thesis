\documentclass[../EDF Master Thesis.tex]{subfiles}

\begin{document}

Der \ac{edf} Scheduler lässt sich mit einer einzelnen C-Datei, sowie einer Header-Datei in \ac{freertos} implementieren.
Dies vereinfacht die Implementierung auf andere \ac{freertos} Versionen, sowie auch das portieren auf andere Plattformen.
Um die Portabilität weiter zu vereinfachen, wurde der \ac{freertos} SystemTick (SysTick) mit der standartmäßigen Genauigkeit von einer Millisekunde und nicht ein weiterer benutzerdefinierter Timer, wie es die Cortex-M Serie ermöglicht, benutzt.
Aus dieser Entscheidungen resultiert auch die Genauigkeit des Schedulers von einer Millisekunde, wobei auftauchende Interrupts, wie die \ac{cpu} Zeit des SysTick, in dieser Arbeit vernachlässigt werden.
Die Periode des SysTick lässt sich unter der Datei 'FreeRTOSConfig.h' , wie in der \autoref{section:freertos_sys_tick} einstellen, jedoch ändert sich dabei auch die Genauigkeit des \ac{edf} Schedulers.
Als Standart ist bei einer \ac{freertos} Installation eine Millisekunde definiert, welche für den \ac{edf} Scheduler einen guten Kompromiss zwischen Applikationslaufzeit und Genauigkeit bietet.

\begin{lstlisting}[language=C, caption=FreeRTOS Idle Task Hook, label=code:freertos_idle_task_hook]
    #define configTICK_RATE_HZ						( 1000 ) // 1ms SysTick
\end{lstlisting}

\subsection{Implementierung} \label{section:implementierung}
    Um eine einfache und zugleich sehr performante Implementierung eines \ac{edf} Schedulers in \ac{freertos} zu gewährleisten, wurde in dieser Arbeit der \ac{freertos} Scheduler weiterverwendet.
    Der \ac{freertos} Scheduler arbeitet, wie in \autoref{section:freertos_scheduling_richtlinie} bereits behandelt, prioritätsbasiert.
    Mit dem Aufruf der Funktion 'rescheduleEDF' am Ende jeder \ac{edf} Task, wird zwischen allen erstellten \ac{edf} Tasks, die Priorität der nächsten Task nachdem \ac{edf}-Prinzip auf die höchste Priorität gesetzt und die aktive Task auf eine niedere Priorität als die \ac{freertos} Idle Task gesetzt.
    Anschließend wird ein Context Switch ausgelöst und die nach dem \ac{edf}-Prinzip nächste Task wird mit \ac{freertos} Scheduler aufgerufen und ausgeführt.
    Falls alle \ac{edf} Tasks bereits in Ihrer Periode ausgeführt wurden und alle Deadlines der Tasks weiter als ihre Periode in der Zukunft liegen, wird die \ac{freertos} Idle Task aufgerufen.

    \begin{table}[ht!]
        \centering
        \begin{tabular}{l|c}
            Tasks & Priorität \\
            \hline
            Deaktivierte \ac{edf} Task(s) & 0\\
            \ac{freertos} Idle Task & 1\\
            Auführende \ac{edf} Task & 2\\
            'rescheduleEDF' ausführende Task & 3
        \end{tabular}
        \caption{\ac{edf}-Prioritäten der Tasks}
        \label{table:edf_prioritaeten_der_tasks}
    \end{table}

    Der \ac{edf} Scheduler arbeitet mit vier unterschiedlichen Prioritäten, wie in \autoref{table:edf_prioritaeten_der_tasks} dargestellt und inkrementiert bei der Implementierung die Idle Task von der niedrigsten Priorität '0' auf die zweit niedrigste Priorität '1' in der \ac{freertos} Umgebung.
    Alle \ac{edf} Tasks die nicht ausgeführt werden sollen, erhalten die Priorität 0, das führt dazu, dass die Idle Task immer ausgeführt wird und verhindert die nicht gewollte Ausführung einer \ac{edf} Task.
    Um ein \ac{edf} Scheduling in der Idle Task zu ermöglichen, wird die 'rescheduleEDF'-Funktion mit Hilfe des Idle Task Hook, wie in \autoref{code:freertos_idle_task_hook} beschrieben, aufgerufen.
    Die Task, welche aktuell ausgeführt wurde und nun am Ende die 'rescheduleEDF'-Funktion ausführt, erhält während der Funktionsausführung die höchste \ac{edf}-Priorität mit dem Wert '3', um einen vorzeitigen Context Switch zur nächsten, nach dem \ac{edf}-Prinzip ausgewählte Task, zu unterbinden.
    Nachdem alle \ac{edf}-Parameter von allen \ac{edf} Tasks neu gesetzt wurden, gibt die aktuelle Task die höchste Priorität mit dem '3' ab und erzwingt einen Context Switch zu der nächsten zu ausführenden \ac{edf} Task mit der Priorität '2'.
    Für einen reibungslosen Start des \ac{edf} Schedulers, werden die Prioritäten aller \ac{edf} Tasks nachdem Erstellen automatisch auf die Priorität mit dem Wert '0' gesetzt, damit die Idle Task die allerste Ausführung übernimmt und somit die 'rescheduleEDF'-Funktion durch den Idle Task Hook ausgeführt wird.
    
    \begin{center}
        \begin{tikzpicture}[node distance = 2cm, auto]
            % \draw[very thin,lightgray](-2,-9)grid[step=.5cm]+(6,10);
        
            % Place nodes
            \node [papStart] (Start1){Start};
            \node [papProcess, below = of Start1,label={[papLabel]right:label 1}](pro1){Prozess};
            \node [papProcess, below = of pro1,label={[papLabel]right:label 2}](pro2){Prozess};
            \node [papEnd, below = of pro2, yshift= -20mm] (End) {Ende};
        
            % Draw edges
            \path [papLine] (Start1) -- (pro1);
            \path [papLine] (pro1) -- (pro2);
            \path [papLine] (pro2) -- (End);
        \end{tikzpicture}  
    \end{center}
    
    Bei der Berechnung der Prioritäten in der 'rescheduleEDF'-Funktion wird dabei die Deadline abzüglich der \ac{wcet} berücksichtigt, um nicht einer Task \ac{cpu}-Zeit zu geben, welche sowieso Ihre Deadline überschreiten würde.
    Um einen Einblick in das Scheduling-Verfahren, mit der in dieser Arbeit implementierten \ac{edf} Schedulers, zu bekommen, wurde der Ablauf, in \autoref{fig:demonstrationsablauf_des_edf_schedulers} dargestellt, von drei Tasks mit den Eigenschaften wie in \autoref{table:demonstrationsablauf_task_eigenschaften} beschrieben, erstellt.

    \begin{table}[ht!]
        \centering
        \begin{tabular}{l|c|c|c}
            Taskname & Periode & Deadline & \ac{wcet} \\
            \hline
            Task 1 & 5 & 3 & 1 \\
            Task 2 & 5 & 5 & 2 \\
            Task 3 & 10 & 10 & 1 
        \end{tabular}
        \caption{Demonstrationsablauf Task Eigenschaften}
        \label{table:demonstrationsablauf_task_eigenschaften}
    \end{table}


    \begin{figure}[ht!]
        \centering
        \sffamily
        \begin{tikzpicture}
        \begin{ganttchart}[%
            hgrid,
            inline, 
            y unit title=1.1cm,
            canvas/.style={draw=none},
            title/.style={draw=none},
            bar inline label anchor=west,
            bar inline label node/.append style={anchor=west, text=white},
            bar/.append style={fill=cyan!90!black,}, 
            bar height=1,
            bar top shift = 0]{0}{19}
        \ganttbar[inline=false, bar/.append style={fill=blue!50}, bar label font=\color{blue!50}]{Task 1}{0}{0}
        \ganttbar[bar/.append style={fill=blue!50}]{}{5}{5}
        \ganttbar[bar/.append style={fill=blue!50}]{}{10}{10}
        \ganttbar[bar/.append style={fill=blue!50}]{}{15}{15}\\
        \ganttbar[inline=false, bar/.append style={fill=blue!70}, bar label font=\color{blue!70}]{Task 2}{1}{2}
        \ganttbar[bar/.append style={fill=blue!70}]{}{6}{7}
        \ganttbar[bar/.append style={fill=blue!70}]{}{11}{12}
        \ganttbar[bar/.append style={fill=blue!70}]{}{16}{17}\\
        \ganttbar[inline=false, bar/.append style={fill=blue!90}, bar label font=\color{blue!90}]{Task 3}{3}{3}
        \ganttbar[bar/.append style={fill=blue!90}]{}{13}{13}\\
        \ganttbar[inline=false, bar label font=\color{cyan!90}]{Idle Task}{4}{4}
        \ganttbar{}{8}{9}
        \ganttbar{}{14}{14}
        \ganttbar{}{18}{19}\\
        % \ganttvrule[vrule/.append style={red}]{P(T1, T2)}{4}
        % \ganttvrule[vrule/.append style={red}]{P(T1, T2, T3)}{9}
        % \ganttvrule[vrule/.append style={red}]{P(T1, T2)}{14}
        \gantttitlelist[title label node/.append style={alias=n\x,opacity=0}]{0,...,19}{1}
        \end{ganttchart}
        \draw [-latex] (n0.north west) -- ([xshift=7pt]n19.north east) node[right] {$t$};
        \foreach \N in {0,...,19} {
            \draw
            let
            \p1=(n0.center), \p2=(n1.center),\n1={(\x2-\x1)/2}
            in
            (n\N.north) +(-\n1,2pt) -- +(-\n1,-2pt) node[below,font=\small]{\N};
        }
        
        % draw tick for 19
        \draw
            let
            \p1=(n0.center), \p2=(n1.center),\n1={(\x2-\x1)/2}
            in
            (n19.north) +(\n1,2pt) -- +(\n1,-2pt) node[below,font=\small]{20};
        
        \end{tikzpicture}\\
        \caption{Demonstrationsablauf des \ac{edf} Schedulers}
        \label{fig:demonstrationsablauf_des_edf_schedulers}
    \end{figure}

    Bei der Darstellung in \autoref{fig:demonstrationsablauf_des_edf_schedulers} wurde die Anfangsphase so wie der erste Aufruf der Idle Task vernachlässigt, des Weiteren wurde als Vereinfachung der Darstellung der Starttick der ersten Task als null angenommen.
    Als erstes bekommt die Task 1 \ac{cpu}-Zeit zugeteilt, da diese die kürzeste Deadline besitzt.
    Anschließend wird Task 2 ausgeführt, welche die nächst kürzeste Deadline besitzt und als letztes wird Task 3 ausgeführt.
    Nachdem nun alle drei Tasks innerhalb Ihrer Periode unter Einhaltung der Deadlines ausgeführt wurden, wird die Idle Task solange ausgeführt, bis die nächste Periode einer Task beginnt.


\subsection{Erstellung einer \c{edf} Task} \label{section:erstellung_einer_edf_task}

    Für die 

\subsection{Kompatibilität}

    Durch die Verwendung des originalen Schedulers können klassische \ac{freertos} Tasks parallel erstellt und abgearbeitet werden.
    Hierbei ist aber zu Beachten, dass die Priorität der klassischen \ac{freertos} Task eine höhere Priorität als den Wert '3' besitzt, da es ansonsten zu Konflikten innerhalb des \ac{edf} Schedulers kommen kann.
    Auch sollte bei der Implementierung von klassischen \ac{freertos} Task darauf geachtet werden, dass die \ac{edf} Tasks genügend Zeit für Ihre Abarbeitung zur Verfügung gestellt bekommen.


\subsection{Fehlerbehandlung} \label{section:Fehlerbehandlung}

    Sollten zwei \ac{edf} Tasks die gleichen Deadline besitzen, wird die Task, die bisher weniger Ausführungen vorweist, als nächste zu ausführende Task ausgesucht.
    Falls eine Task ihre Deadline überschritten hat oder die Zeit für die Ausführung nicht mehr reicht, werden die \ac{edf} Parameter angepasst.
    Dadurch wird keine Task bei der Fehlerbehandlung bevorzugt oder benachteiligt, wobei natürlich die Task mit der kürzesten Deadline und der kleinsten Periode eine höhere Wahrscheinlichkeit besitzt, ausgeführt zu werden. 

\subsection{Debug Mode} \label{section:debug_mode}

    
    



\end{document}

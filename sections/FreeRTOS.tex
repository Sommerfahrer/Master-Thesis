\documentclass[../EDF Master Thesis.tex]{subfiles}

\begin{document}
\ac{freertos} ist ein Echtzeitbetriebssystem für eingebettete Systeme, welches unter der freizügigen Open-Source Lizenz \href{https://de.wikipedia.org/wiki/MIT-Lizenz}{MIT} steht.
Für eine leichte Wartbarkeit wurde \ac{freertos} weitestgehend in C entwickelt, außerdem ist der Scheduler des Betriebsystems zwischen präemptiver und kooperativer Betrieb konfigurierbar um verschiedene Einsatzzwecke abzudecken \parencite{wiki:002}.
Des Weiteren wurde \ac{freertos} auf über 40 Mikrocontroller-Architekturen portiert \parencite{freertos}, um eine größere Bandbreite zu erreichen.
\ac{freertos} hat wenig Overhead und der Kernel unterstützt Multithreading, Warteschlangen, Semaphore, Software-Timer, Mutexes und Eventgruppen \parencite{freertos-features}.
Des Weiteren stellt \ac{freertos} unter der Bezeichnung "FreeRTOS Plus" verschiedene Erweiterungen zur Verfügung, welche erweiterte Funktionen bereitstellen \parencite{freertos-extensions}.
\begin{itemize}
    \item \textbf{FreeRTOS + TCP}: Socketbasiertes \acs{tcp}/\acs{udp}/\acs{ip} Interface.
    \item \textbf{Application Protocols}: \acs{mqtt} und \acs{http} Anwendungsprotokolle für \acs{iot}.
    \item \textbf{coreJson}: Effizienter Parser für \acs{json}
    \item \textbf{corePKCS\#11}: Verschlüsselungs \acs{api}-Layer
    \item \textbf{FreeRTOS + IO}: Erweiterung für Peripheriegeräte
    \item \textbf{FreeRTOS + CLI}: Effiziente \acs{cli}-Eingaben
\end{itemize}

Im Zuge dieser Masterarbeit wurde als einziges der Stack '\ac{freertos} + \acs{tcp}' für die Verbindung zwischen Computer und Mikrocontroller verwendet.

\subsubsection{\ac{freertos} Scheduling Richtlinie} \label{section:freertos_scheduling_richtlinie}
Der \ac{freertos} Scheduler arbeitet prioritätsbasiert und beinhaltet standartmäßig zwei Eigenschaften:
\begin{itemize}
    \item \textbf{Time Slicing Scheduling Policy}: Tasks mit gleicher Priorität erhalten die gleiche Anteile an \ac{cpu}-Zeit, dieses Verfahren ist auch als 'Round-Robin Algorithmus' bekannt.
    \item \textbf{Fixed Priority Preemptive Scheduling}: Es wird immer die Task  mit der höchsten Priorität ausgeführt.
                                                         Das bedeutet eine niedriger priorisierte Task bekommt nur \ac{cpu}-Zeit, wenn die höher priorisierten Tasks nicht den 'ready'-Status besitzen.
                                                         Teilen sich zwei Tasks gleichzeitig die höchste Priorität, tritt die Time Slicing Scheduling Policy in Kraft.
\end{itemize}
Um einen oder beide dieser Eigenschaften abzuschalten, kann dies unter der Datei 'FreeRTOSConfig.h', wie in \autoref{code:freertos_scheduling_policies} dargestellt, abgeändert werden \parencite{freertos-scheduling-policy}.
\begin{lstlisting}[language=C, caption=FreeRTOS Scheduling Policy Properties, label=code:freertos_scheduling_policies]
    #define configUSE_PREEMPTION                    ( 1 )
    #define configUSE_TIME_SLICING                  ( 1 )
\end{lstlisting}


\subsubsection{Overhead und Footprint} \label{section:overhead_und_footprint}
Die Dauer eines Context Switches, auch Taskwechsel genannt, zwischen zwei Tasks ist abhängig von dem Port, dem Compiler und der Konfiguration von FreeRTOS.
FreeRTOS selbst gibt ein Beispiel anhand einer Cortex-M3 CPU eine Taskwechsel Zeit von 84 \ac{cpu} Zyklen an \parencite{freertos-overhead}.
Der minimale \ac{ram}- und \ac{rom}-Footprint wird zwischen 6kByte und 12kByte angegeben \parencite{freertos-footprint}.

\subsubsection{Task States} \label{section:task_states}
In FreeRTOS erzeugte Tasks können vier verschiedene Zustände haben \parencite{freertos-task-states}:

\begin{itemize}
    \item \textbf{Running}: Wird gerade ausgeführt.
    \item \textbf{Ready}: Ist bereit zur Ausführung.
    \item \textbf{Blocked}: Wartet auf ein Event, kann nicht ausgeführt werden.
    \item \textbf{Suspended}: Wurde temporär deaktiviert.
\end{itemize}

Ein Ablaufdiagramm der einzelnen Zustände und deren Wechsel mit Hilfe von \ac{freertos} Funktionen wird in \autoref{fig:FreeRTOS_Task_States} dargestellt.

\begin{figure}[H]
    \centering
    \includegraphics[height=10cm, width=10cm]{./attachments/FreeRTOS_Task_States.pdf}
    \caption{FreeRTOS Task States \ac{iaa}: \parencite{freertos-task-states}}
    \label{fig:FreeRTOS_Task_States}
\end{figure}

\subsection{Idle Task} \label{section:idle_task}
Die \ac{freertos} Idle Task wird immer dann aufgerufen, wenn keine Task ausgeführt werden kann.
Dabei wird die \ac{freertos} Idle Task automatisch beim Start des \ac{freertos}-Schedulers mit der niedrigsten verfügbaren Priorität erstellt, um keine Tasks im 'ready' Status zu blockieren.
Das heißt die Idle Task wird nur ausgeführt, wenn keine Task eine höhere Priorität als die Idle Task Priorität hat oder keine Task die eine höhere Priorität hat sich im 'ready' Status befindet.
Sollte eine Task die gleiche Priorität mit der Idle Task teilen, wird die \ac{cpu}-Zeit, bei Standartkonfiguration, zwischen den zwei Tasks aufgeteilt.
Des Weiteren wird die Idle Task in \ac{freertos} Standartkonfiguration mit der Priorität 0, also der niedrigsten Priorität gestartet.
Beim Ausführen der \ac{freertos} Idle Task wird der zugewiesener Speicher von gelöschten Tasks endgültig gelöscht und sollte somit regelmäßig \ac{cpu}-Zeit bekommen, da ansonsten der Arbeitsspeicher überlaufen kann.
Des Weiteren kann mit der Flag, wie in \autoref{code:freertos_idle_task_hook} zu sehen, der Idle Task Hook aktiviert werden.
Der Idle Task Hook wird bei jedem Aufruf der Idle Task ausgeführt und ermöglicht dem Benutzer dabei einen zusätzlichen Code auszuführen.
Dies kann für verschiedene Einsatzbereiche benutzt werden, \ac{zb} den Mikrocontroller in den Energiesparmodus zu setzen.

\begin{lstlisting}[language=C, caption=FreeRTOS Idle Task Hook, label=code:freertos_idle_task_hook]
    #define configUSE_IDLE_HOOK                     ( 1 )
\end{lstlisting}


\subsubsection{Interrupts} \label{section:interrupts}
Interrupts werden durch ein Ereignis ausgelöst, \ac{zb} von einem bestimmten Wert eines Timers und führt zur einer Unterbrechung der aktuellen Programmausführung, um in der Regel kurzen, aber zeitlich kritischen, Vorgang abzuarbeiten.
Nach der Unterbrechungsanforderung (\ac{irq}) führt der Prozessor eine Unterbrechungsroutine (\ac{isr}) mit erweiterten Privilegien aus.
Im Anschluss wird der vorherige Zustand des Prozessors wiederhergestellt und die vorherige Ausführung an der unterbrochenen Stelle fortgesetzt \parencite{wiki:008}.


\subsubsection{\ac{freertos} Sys-Tick} \label{section:freertos_sys_tick}
Der \ac{freertos} Sys-Tick, auch System Tick genannt, ist fundemental für die Taskwechsel in \ac{freertos}, dieser Interrupt wird standartmäßig jede Millisekunde aufgerufen.
Dieser Wert bietet eine gute Balance zwischen Taskgeschwindigkeit und Overhead von Taskwechsel.
Bei jedem Sys-Tick wird die \ac{freertos} Funktion 'vTaskSwitchContext()' aufgerufen, diese überprüft ob eine höher priorisierte Task unblocked, also ausführbar geworden ist und falls dies zutrifft wird ein Taskwechsel auf die höher priorisierte Task durchgeführt.

\subsubsection{\ac{freertos} Queues} \label{section:queues}
Queues, zu Deutsch Warteschlange, werden oft, auch außerhalb von \ac{freertos} für die sichere Kommunikation zwischen verschiedenen Tasks und/oder Interrupts verwendet.
Diese Implementierung von \ac{freertos} vermeidet Fehler wie \ac{zb} eine höher priorisierte Task wartet auf einen Wert einer niederen priorisierten Task, wobei die niedere priorisierte Task nie ausgeführt wird.
Bei Queues wird oft das Prinzip \ac{fifo} verwendet, um eine zeitliche Abarbeitung der Daten zu gewährleisten.
\end{document}
